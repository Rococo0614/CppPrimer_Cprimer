6.关于图
图的存储：首先我们要知道，图一般都有什么？
图有端点N，端点之间有边M，边可能有方向也可能没有方向。
图:        无向            |          有向
最大边数:   n*(n-1) / 2             n*(n-1)
有自环    n*(n-1) / 2  + n = n * (n + 1) / 2   |    n*(n-1)  + n = n.^2

五种常用的模板
邻接表:
vector<vector<int>> adj(N + 1);

for (int i = 0; i < M; i++) {
    int u, v;
    cin >> u >> v;
    adj[u].push_back(v);   // 有向图
    // adj[v].push_back(u);  // 若是无向图
}
遍历所有出边：for (int v : adj[u]) {...}

内存复杂度：O(N + M)
访问复杂度：O(出度)

邻接矩阵:适用稠密图/小规模图
vector<vector<int>> g(N + 1, vector<int>(N + 1, 0));

for (int i = 0; i < M; i++) {
    int u, v;
    cin >> u >> v;
    g[u][v] = 1; // 或权重
}
判断是否有边：O(1)

遍历所有边：O(N²)

缺点：N=10⁵ 就占 10¹⁰ 空间，不可行。

边列表：当我们关注边的时候
struct Edge { int u, v, w; };
vector<Edge> edges;

for (int i = 0; i < M; i++) {
    int u, v, w;
    cin >> u >> v >> w;
    edges.push_back({u, v, w});
}
不支持“从某个点找所有出边”

支持“遍历所有边”
→ 常用于：Kruskal 最小生成树、图遍历统计、离线构造题

前向星:
struct Edge {
    int to, next;
} e[MAXM];

int head[MAXN], tot = 0;

void addEdge(int u, int v) {
    e[++tot] = {v, head[u]};
    head[u] = tot;
}
所有出边存放在数组 e 中；

head[u] 记录该点出边链表的起始下标；

内存连续，访问快；

不易动态修改。

常用于：最短路（Dijkstra）、网络流、图搜索（BFS/DFS）

哈希表
vector<unordered_set<int>> adj(N + 1);

adj[u].insert(v);
if (adj[u].count(v)) { ... }
支持 O(1) 平均插入/查找；

不适合高性能算法；

用在需要灵活修改的模拟题中。

7.关于树
