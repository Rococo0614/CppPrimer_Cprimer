#判断质数
这是一类非常经典的题目，一开始针对小的数的想法是判断整除
bool isPrime(x){
    for(int i = 2; i * i <= x; i++){
        if(x % i == 0) return false;
    }
    return true;
};

后来，我们嫌弃这个方法太慢，我们就从小学课本中学习到了筛法，包括艾式筛和欧拉筛,这种方法一般是来判断一定范围区间内有多少质数的
vector<int> vise_of_Estera(int x){
    if(x < 2) return 0;
    vector<bool> isPrime(n+1,true);
    vector<int> Prime(n);
    for(int i - 2; i * i <= x; i++){
        if(isPrime[i]){
            for(int j = i * i; j <= N; j+= i){
                isPrime[i] = false;
            }
        }
    }
    for (int i = 2; i <= N; ++i)
    if (is_prime[i]) Primes.push_back(i);
    return Primes;
}


vector<int> vise_of_eula(int x){
    vector<bool> is_composite(x+1);
    vector<int> primes;

    for(int i = 2; i <= x; i++){
        if(!is_composite[i]) primes.push_back(i);
        for(int p : primes){
            if ((long long) i * p > x) break;
            is_composite[i*p] = true;
            if ( i % p == 0) break;
        }
    }

    return primes;

}

我们虽然解决了判断一个大范围内有多少的问题，但是起初的问题——高效判断是否为质数的问题并没有解决,
我们引入一个方法
确定性的 Miller–Rabin 素性检测
原定理基于fermat小定理：如果p是质数，a是小于p的整数，那么一定满足
(a.^(p-1)) % p == 1
注意，这里的条件是必要不充分的，因此我们要加强判断
考虑把p-1写成能被2的整除的最大次数的形式 p-1 = (2.^s) * d,那么d就是奇数
然后，检查这条平方链 a.^d a.^2d ..... a.^(2.^(s-1) * d) a.^(2,^ s) * d 所有数字都 % p
我们看这条平方链，理论上来说，每一个被除的数都是前一个数字的平方，我们对取模后的数字进行判断
如果在选取合适的基，得到的所有平方链中，当他有一位是1,且前一位不是-1的时候，那么他一定不是质数；
反之，如果限定的数在限定的范围内为1结果的前一位都是-1,那么可以认为他是质数
具体的限定范围
32位int型 : a = {2, 3, 5, 7, 11}
64位:       a = {2 ,3 ,5, 7 ,11 ,13, 17}足以
