#判断质数
这是一类非常经典的题目，一开始针对小的数的想法是判断整除
bool isPrime(x){
    for(int i = 2; i * i <= x; i++){
        if(x % i == 0) return false;
    }
    return true;
};

后来，我们嫌弃这个方法太慢，我们就从小学课本中学习到了筛法，包括艾式筛和欧拉筛,这种方法一般是来判断一定范围区间内有多少质数的
vector<int> vise_of_Estera(int x){
    if(x < 2) return 0;
    vector<bool> isPrime(n+1,true);
    vector<int> Prime(n);
    for(int i - 2; i * i <= x; i++){
        if(isPrime[i]){
            for(int j = i * i; j <= N; j+= i){
                isPrime[i] = false;
            }
        }
    }
    for (int i = 2; i <= N; ++i)
    if (is_prime[i]) Primes.push_back(i);
    return Primes;
}


vector<int> vise_of_eula(int x){
    vector<bool> is_composite(x+1);
    vector<int> primes;

    for(int i = 2; i <= x; i++){
        if(!is_composite[i]) primes.push_back(i);
        for(int p : primes){
            if ((long long) i * p > x) break;
            is_composite[i*p] = true;
            if ( i % p == 0) break;
        }
    }

    return primes;

}

我们虽然解决了判断一个大范围内有多少的问题，但是起初的问题——高效判断是否为质数的问题并没有解决,
我们引入一个方法
确定性的 Miller–Rabin 素性检测
原定理基于fermat小定理：如果p是质数，a是小于p的整数，那么一定满足
(a.^(p-1)) % p == 1
注意，这里的条件是必要不充分的，因此我们要加强判断
考虑把p-1写成能被2的整除的最大次数的形式 p-1 = (2.^s) * d,那么d就是奇数
然后，检查这条平方链 a.^d a.^2d ..... a.^(2.^(s-1) * d) a.^(2,^ s) * d 所有数字都 % p
我们看这条平方链，理论上来说，每一个被除的数都是前一个数字的平方，我们对取模后的数字进行判断
如果在选取合适的基，得到的所有平方链中，当他有一位是1,且前一位不是-1的时候，那么他一定不是质数；
反之，如果限定的数在限定的范围内为1结果的前一位都是-1,那么可以认为他是质数
具体的限定范围
32位int型 : a = {2, 3, 5, 7, 11}
64位:       a = {2 ,3 ,5, 7 ,11 ,13, 17}足以
#include <bits/stdc++.h>
using namespace std;
using u64 = unsigned long long;
using u128 = __uint128_t;

u64 mod_pow(u64 a, u64 d, u64 n) {
    u64 res = 1;
    while (d) {
        if (d & 1) res = (u128)res * a % n;
        a = (u128)a * a % n;
        d >>= 1;
    }
    return res;
}快速求幂次方后mod值运算

bool miller_rabin(u64 n) {
    if (n < 2) return false;
    for (u64 p : {
                2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37
            })
        if (n % p == 0) return n == p;

    // 分解 n - 1 = 2^s * d
    int s = __builtin_ctzll(n - 1);
    u64 d = (n - 1) >> s;

    // 一组确定性的底数（64位安全）
    for (u64 a : {
                2, 325, 9375, 28178, 450775, 9780504, 1795265022
            }) {
        if (a % n == 0) continue;
        u64 x = mod_pow(a, d, n);
        if (x == 1 || x == n - 1) continue;
        bool comp = true;
        for (int r = 1; r < s; r++) {
            x = (u128)x * x % n;
            if (x == n - 1) {
                comp = false;
                break;
            }
        }
        if (comp) return false; // composite
    }
    return true; // probably prime
}

int main() {
    u64 n;
    while (cin >> n)
        cout << (miller_rabin(n) ? "Yes\n" : "No\n");
}

#求gcd和lcm
辗转相除求最大公因数
(a / gcd) * lcm 得最小公倍数

当你看到一个整数计算是 a / i和 a % i时候，可以联想到其实就是将a展开在i进制
其中a / i其实就是展开成i进制后的基数之外的数，而a % i就是a展开成i进制后的基数
所以其实对于i = 2的情况下， 你可以得到非常好且对于计算机来说计算非常快的性质
例如: a / 2 其实就是看排除末尾看二进制,或者说a右移一个二进制单位，而a % 2就是看二进制的末尾是什么
就像十进制的计算一样

1en是1x10^n也就是后面有n个0